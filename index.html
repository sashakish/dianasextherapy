<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intimate Connections — Sex Therapy & Relationship Counseling</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;0,600;1,300;1,400&family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --cream: #FFFFFF;
            --warm-white: #FAFBF6;
            --blush: #E8D5CC;
            --dusty-rose: #C4A092;
            --deep-plum: #3D2B3D;
            --soft-charcoal: #2E2E2E;
            --muted-gold: #B89F7E;
            --sage: #8FA08A;
        }

        html { scroll-behavior: smooth; }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background-color: var(--cream);
            color: var(--soft-charcoal);
            line-height: 1.7;
            font-weight: 300;
            -webkit-font-smoothing: antialiased;
        }

        /* ─── NAV ─── */
        nav {
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 100;
            padding: 1.5rem 3rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.4s, backdrop-filter 0.4s;
        }
        nav.scrolled {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }
        nav .logo {
            display: flex;
            align-items: center;
        }
        nav .logo img {
            height: 60px;
            width: auto;
        }
        nav ul {
            list-style: none;
            display: flex;
            gap: 2.5rem;
        }
        nav a {
            text-decoration: none;
            color: var(--soft-charcoal);
            font-size: 0.85rem;
            font-weight: 400;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            transition: color 0.3s;
        }
        nav a:hover { color: var(--dusty-rose); }

        /* ─── BUTTONS ─── */
        .btn {
            display: inline-block;
            padding: 1rem 2.5rem;
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            font-weight: 400;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            text-decoration: none;
            border: none;
            cursor: pointer;
            transition: all 0.4s ease;
        }
        .btn-primary {
            background: var(--deep-plum);
            color: var(--cream);
            border-radius: 50px;
        }
        .btn-primary:hover {
            background: #52375A;
            transform: translateY(-2px);
            box-shadow: 0 12px 30px rgba(61, 43, 61, 0.25);
        }
        .btn-outline {
            background: transparent;
            color: var(--deep-plum);
            border: 1px solid var(--dusty-rose);
            border-radius: 50px;
            margin-left: 1rem;
        }
        .btn-outline:hover {
            background: var(--dusty-rose);
            color: white;
        }
        .btn-light {
            background: rgba(255, 255, 255, 0.15);
            color: var(--cream);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50px;
        }
        .btn-light:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
        }

        /* ─── SECTION COMMON ─── */
        .section-label {
            font-size: 0.75rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: var(--dusty-rose);
            margin-bottom: 1rem;
        }
        .section-title {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(2rem, 3.5vw, 3rem);
            font-weight: 300;
            color: var(--deep-plum);
            margin-bottom: 1.5rem;
            line-height: 1.2;
        }

        /* ─── HERO ─── */
        .hero {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6rem 3rem;
            position: relative;
            overflow: hidden;
        }
        .hero-inner {
            max-width: 1200px;
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5rem;
            align-items: center;
        }
        .hero-text h1 {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(2.8rem, 5vw, 4.5rem);
            font-weight: 300;
            line-height: 1.15;
            color: var(--deep-plum);
            margin-bottom: 1.5rem;
        }
        .hero-text h1 em {
            font-style: italic;
            font-weight: 400;
            color: var(--dusty-rose);
        }
        .hero-text p {
            font-size: 1.1rem;
            color: #666;
            max-width: 440px;
            margin-bottom: 2.5rem;
            line-height: 1.8;
        }
        .hero-video-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .hero-video-wrapper {
            position: relative;
            width: 100%;
            max-width: 580px;
        }
        .hero-vid {
            width: 100%;
            height: auto;
            mix-blend-mode: multiply;
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
        }
        .hero-vid:first-child {
            position: relative;
        }
        .hero-vid.hero-active {
            opacity: 1;
            pointer-events: auto;
        }

        /* ─── SERVICE SECTIONS (full-width stacked) ─── */
        .service-section {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6rem 3rem;
            position: relative;
            overflow: hidden;
        }
        .service-inner {
            max-width: 1100px;
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5rem;
            align-items: center;
        }
        .service-inner.reverse {
            direction: rtl;
        }
        .service-inner.reverse > * {
            direction: ltr;
        }
        .service-text h2 {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(2.2rem, 4vw, 3.5rem);
            font-weight: 300;
            line-height: 1.15;
            color: var(--deep-plum);
            margin-bottom: 1rem;
        }
        .service-text h2 em {
            font-style: italic;
            font-weight: 400;
            color: var(--dusty-rose);
        }
        .service-text p {
            font-size: 1.05rem;
            color: #666;
            line-height: 1.9;
            margin-bottom: 1.5rem;
        }
        .service-video-wrapper {
            position: relative;
            width: 100%;
        }
        .service-video-wrapper video {
            width: 100%;
            height: auto;
            display: block;
            mix-blend-mode: multiply;
        }

        /* Section color variations */
        .section-warm { background: var(--warm-white); }
        .section-white { background: var(--cream); }
        .section-blush { background: #FDF6F3; }
        .section-sage { background: #F4F7F3; }

        /* Dark section */
        .section-dark {
            background: var(--deep-plum);
        }
        .section-dark .service-text h2 {
            color: var(--cream);
        }
        .section-dark .service-text h2 em {
            color: var(--muted-gold);
        }
        .section-dark .service-text p {
            color: rgba(255, 255, 255, 0.65);
        }
        .section-dark .section-label {
            color: var(--muted-gold);
        }

        /* ─── ABOUT DIANA ─── */
        .about {
            padding: 7rem 3rem;
        }
        .about-inner {
            max-width: 1100px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4rem;
            align-items: center;
        }
        .about-content p {
            font-size: 1.05rem;
            color: #666;
            line-height: 1.9;
            margin-bottom: 1rem;
        }
        .about-video {
            order: -1;
        }
        .about-video video {
            width: 100%;
            height: auto;
            display: block;
        }
        .divider {
            width: 60px;
            height: 1px;
            background: var(--blush);
            margin: 2rem 0;
        }

        /* ─── CTA ─── */
        .cta {
            text-align: center;
            background: var(--warm-white);
            padding: 8rem 3rem;
        }
        .cta .section-title { margin-bottom: 1rem; }
        .cta p {
            font-size: 1.05rem;
            color: #888;
            max-width: 500px;
            margin: 0 auto 2.5rem;
        }

        /* ─── FOOTER ─── */
        footer {
            padding: 3rem;
            text-align: center;
            background: var(--cream);
            border-top: 1px solid var(--blush);
        }
        footer p {
            font-size: 0.8rem;
            color: #aaa;
            letter-spacing: 0.05em;
        }

        /* ─── ANIMATIONS ─── */
        .fade-up {
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }
        .fade-up.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* ─── RESPONSIVE ─── */
        @media (max-width: 900px) {
            .hero-inner { grid-template-columns: 1fr; text-align: center; gap: 3rem; }
            .hero-text p { margin-left: auto; margin-right: auto; }
            .hero-video-wrapper { width: 100%; max-width: 100%; }
            .service-inner { grid-template-columns: 1fr; gap: 3rem; }
            .service-inner.reverse { direction: ltr; }
            .service-section { min-height: auto; padding: 4rem 2rem; }
            .about-inner { grid-template-columns: 1fr; gap: 2rem; }
            .about-video { order: 1; }
            nav ul { display: none; }
        }
    </style>
</head>
<body>

    <!-- Nav -->
    <nav id="nav">
        <a href="#" class="logo"><img src="logo.png" alt="Diana Urman"></a>
        <ul>
            <li><a href="#confidence">Services</a></li>
            <li><a href="#about">About</a></li>
            <li><a href="#contact">Contact</a></li>
        </ul>
    </nav>

    <!-- ═══════════════════════════════════════════ -->
    <!-- HERO -->
    <!-- ═══════════════════════════════════════════ -->
    <section class="hero">
        <div class="hero-inner">
            <div class="hero-text fade-up">
                <h1>Rediscover <em>intimacy</em> without shame</h1>
                <p>A safe, compassionate space to explore your sexuality, deepen connection, and heal — individually or with your partner.</p>
                <div>
                    <a href="#contact" class="btn btn-primary">Book a Session</a>
                    <a href="#confidence" class="btn btn-outline">Explore Services</a>
                </div>
            </div>
            <div class="hero-video-container fade-up">
                <div class="hero-video-wrapper">
                    <video id="hero0fwd" muted playsinline preload="auto" src="hero1-forward.mp4" class="hero-vid hero-active"></video>
                    <video id="hero0rev" muted playsinline preload="auto" src="hero1-reverse.mp4" class="hero-vid"></video>
                    <video id="hero1fwd" muted playsinline preload="auto" src="hero2-forward.mp4" class="hero-vid"></video>
                    <video id="hero1rev" muted playsinline preload="auto" src="hero2-reverse.mp4" class="hero-vid"></video>
                </div>
            </div>
        </div>
    </section>

    <!-- ═══════════════════════════════════════════ -->
    <!-- EXPAND CONFIDENCE -->
    <!-- ═══════════════════════════════════════════ -->
    <section class="service-section section-warm" id="confidence">
        <div class="service-inner fade-up">
            <div class="service-text">
                <p class="section-label">Expand</p>
                <h2>Expand <em>Confidence</em></h2>
                <p>Your relationship with yourself is the foundation of every intimate connection. Together, we'll uncover what holds you back — body image, past experiences, or unspoken fears — and build a confident, embodied sense of self.</p>
                <p>Whether you're exploring your identity, navigating change, or simply wanting to feel more at home in your own skin — this is where it starts.</p>
            </div>
            <div class="service-video-wrapper" data-video-pool="confidence">
                <video id="confidenceFwd" muted playsinline preload="none" class="section-video" src="confidence-forward.mp4" style="width:100%;height:auto">
                </video>
                <video id="confidenceRev" muted playsinline preload="none" src="confidence-reverse.mp4" style="width:100%;height:auto;display:none">
                </video>
            </div>
        </div>
    </section>

    <!-- ═══════════════════════════════════════════ -->
    <!-- REIGNITE PASSION -->
    <!-- ═══════════════════════════════════════════ -->
    <section class="service-section section-white" id="passion">
        <div class="service-inner reverse fade-up">
            <div class="service-text">
                <p class="section-label">Reignite</p>
                <h2>Reignite <em>Passion</em></h2>
                <p>Desire ebbs and flows — that's human. But when disconnection lingers, it can feel like loss. Couples therapy creates space to rebuild communication, rediscover each other, and find your way back to genuine intimacy.</p>
                <p>We work with desire discrepancy, emotional distance, and the everyday friction that quietly erodes connection.</p>
            </div>
            <div class="service-video-wrapper" data-video-pool="passion">
                <video muted playsinline preload="none" class="section-video" style="width:100%;height:auto;mix-blend-mode:multiply">
                </video>
            </div>
        </div>
    </section>

    <!-- ═══════════════════════════════════════════ -->
    <!-- BE ORGASMIC -->
    <!-- ═══════════════════════════════════════════ -->
    <section class="service-section section-blush" id="orgasmic">
        <div class="service-inner fade-up">
            <div class="service-text">
                <p class="section-label">Experience</p>
                <h2>Be <em>Orgasmic</em></h2>
                <p>Pleasure is your birthright — not a luxury. Many people have never been taught how their bodies work, or carry shame that blocks sensation. Through somatic awareness and evidence-based techniques, we'll help you access deeper pleasure and presence.</p>
                <p>This is about more than orgasm. It's about aliveness, embodiment, and feeling fully here.</p>
            </div>
            <div class="service-video-wrapper" data-video-pool="orgasmic">
                <video muted playsinline preload="none" class="section-video" style="width:100%;height:auto;mix-blend-mode:multiply">
                </video>
            </div>
        </div>
    </section>

    <!-- ═══════════════════════════════════════════ -->
    <!-- KETAMINE ASSISTED THERAPY -->
    <!-- ═══════════════════════════════════════════ -->
    <section class="service-section section-dark" id="ketamine">
        <div class="service-inner reverse fade-up">
            <div class="service-text">
                <p class="section-label">Transform</p>
                <h2>Ketamine-Assisted <em>Therapy</em></h2>
                <p>For those who feel stuck — when talk therapy alone isn't enough — ketamine-assisted therapy offers a powerful path to breakthroughs. In a carefully held, medically supervised setting, ketamine can help dissolve rigid patterns, access buried emotions, and open new neural pathways for healing.</p>
                <p>Particularly effective for trauma, treatment-resistant depression, anxiety, and deep-seated blocks around intimacy and connection.</p>
            </div>
            <div class="service-video-wrapper" data-video-pool="ketamine">
                <video muted playsinline preload="none" class="section-video" style="width:100%;height:auto;mix-blend-mode:multiply">
                </video>
            </div>
        </div>
    </section>

    <!-- ═══════════════════════════════════════════ -->
    <!-- ABOUT DIANA -->
    <!-- ═══════════════════════════════════════════ -->
    <section class="about section-white" id="about">
        <div class="about-inner">
            <div class="about-content fade-up">
                <p class="section-label">About the Practice</p>
                <h2 class="section-title">Sexuality is a fundamental part of being human</h2>
                <div class="divider"></div>
                <p>Too often, we carry silence, shame, or confusion around our intimate lives. Whether you're navigating desire discrepancy, recovering from trauma, exploring identity, or simply wanting a more fulfilling connection — therapy can help.</p>
                <p>Our practice offers evidence-based sex therapy in a warm, non-judgmental environment. Every body, every identity, every relationship structure is welcome here.</p>
            </div>
            <div class="about-video fade-up">
                <video id="aboutFwd" muted playsinline preload="none" style="width:100%;height:auto;display:block">
                </video>
                <video id="aboutRev" muted playsinline preload="none" style="width:100%;height:auto;display:none">
                </video>
            </div>
        </div>
    </section>

    <!-- ═══════════════════════════════════════════ -->
    <!-- CTA -->
    <!-- ═══════════════════════════════════════════ -->
    <section class="cta" id="contact">
        <div class="fade-up">
            <p class="section-label">Take the First Step</p>
            <h2 class="section-title">You deserve a fulfilling intimate life</h2>
            <p>Schedule a free 15-minute consultation to see if we're the right fit for your journey.</p>
            <a href="mailto:hello@example.com" class="btn btn-primary">Schedule a Consultation</a>
        </div>
    </section>

    <!-- Footer -->
    <footer>
        <p>&copy; 2026 Intimate Connections Therapy. All rights reserved. &nbsp;·&nbsp; LMFT / AASECT Certified</p>
    </footer>

    <canvas id="stardust" style="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1;"></canvas>

    <script>
        // ─── STARDUST PARTICLES ───
        (() => {
            const canvas = document.getElementById('stardust');
            const ctx = canvas.getContext('2d');
            let w, h;

            const resize = () => {
                w = canvas.width = window.innerWidth;
                h = canvas.height = window.innerHeight;
            };
            resize();
            window.addEventListener('resize', resize);

            const NUM = 60;
            const particles = [];
            for (let i = 0; i < NUM; i++) {
                particles.push({
                    x: Math.random() * 3000,
                    y: Math.random() * 10000, // spread across full page height
                    r: Math.random() * 2 + 0.5,
                    speedX: (Math.random() - 0.5) * 0.3,
                    speedY: (Math.random() - 0.5) * 0.2,
                    twinkleSpeed: Math.random() * 0.02 + 0.005,
                    twinkleOffset: Math.random() * Math.PI * 2,
                });
            }

            // Track which vertical ranges are "light sections"
            const getLightRanges = () => {
                const ranges = [];
                // Hero section
                const hero = document.querySelector('.hero');
                if (hero) {
                    const r = hero.getBoundingClientRect();
                    ranges.push({ top: r.top + window.scrollY, bottom: r.bottom + window.scrollY });
                }
                // Light service sections
                document.querySelectorAll('.section-white, .section-warm, .section-blush, .section-sage').forEach(el => {
                    const r = el.getBoundingClientRect();
                    ranges.push({ top: r.top + window.scrollY, bottom: r.bottom + window.scrollY });
                });
                // About section
                const about = document.querySelector('.about.section-white');
                if (about) {
                    const r = about.getBoundingClientRect();
                    ranges.push({ top: r.top + window.scrollY, bottom: r.bottom + window.scrollY });
                }
                // CTA
                const cta = document.querySelector('.cta');
                if (cta) {
                    const r = cta.getBoundingClientRect();
                    ranges.push({ top: r.top + window.scrollY, bottom: r.bottom + window.scrollY });
                }
                return ranges;
            };

            let lightRanges = getLightRanges();
            window.addEventListener('scroll', () => { lightRanges = getLightRanges(); });
            window.addEventListener('resize', () => { lightRanges = getLightRanges(); });

            const isInLightSection = (pageY) => {
                for (const range of lightRanges) {
                    if (pageY >= range.top && pageY <= range.bottom) return true;
                }
                return false;
            };

            const animate = () => {
                ctx.clearRect(0, 0, w, h);
                const scrollY = window.scrollY;

                particles.forEach(p => {
                    p.x += p.speedX;
                    p.y += p.speedY;

                    // Wrap around
                    if (p.x < -10) p.x = w + 10;
                    if (p.x > w + 10) p.x = -10;
                    if (p.y < -10) p.y += h + 20;
                    if (p.y > 10000) p.y -= 10000;

                    // Screen position
                    const screenY = p.y - scrollY;
                    if (screenY < -20 || screenY > h + 20) return;

                    // Only show in light sections
                    if (!isInLightSection(p.y)) return;

                    // Twinkle
                    const twinkle = Math.sin(Date.now() * p.twinkleSpeed + p.twinkleOffset);
                    const alpha = 0.15 + (twinkle + 1) * 0.25; // 0.15 to 0.65
                    const size = p.r * (0.8 + (twinkle + 1) * 0.3);

                    // Draw sparkle
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#C4A092';
                    ctx.shadowBlur = size * 4;
                    ctx.shadowColor = 'rgba(196, 160, 146, 0.5)';
                    ctx.beginPath();
                    ctx.arc(p.x, screenY, size, 0, Math.PI * 2);
                    ctx.fill();

                    // Cross sparkle for larger particles
                    if (p.r > 1.2 && twinkle > 0.3) {
                        ctx.globalAlpha = alpha * 0.5;
                        ctx.strokeStyle = '#C4A092';
                        ctx.lineWidth = 0.5;
                        const len = size * 3;
                        ctx.beginPath();
                        ctx.moveTo(p.x - len, screenY);
                        ctx.lineTo(p.x + len, screenY);
                        ctx.moveTo(p.x, screenY - len);
                        ctx.lineTo(p.x, screenY + len);
                        ctx.stroke();
                    }
                    ctx.restore();
                });

                requestAnimationFrame(animate);
            };
            animate();
        })();

        // ─── NAV SCROLL ───
        const nav = document.getElementById('nav');
        window.addEventListener('scroll', () => {
            nav.classList.toggle('scrolled', window.scrollY > 50);
        });

        // ─── FADE-UP ON SCROLL ───
        const fadeObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) entry.target.classList.add('visible');
            });
        }, { threshold: 0.15 });
        document.querySelectorAll('.fade-up').forEach(el => fadeObserver.observe(el));

        // ─── LAZY LOAD VIDEOS ───
        // Only load videos when they're within 500px of the viewport
        const lazyVideoObserver = new IntersectionObserver((entries) => {
            entries.forEach(e => {
                if (e.isIntersecting) {
                    const video = e.target;
                    if (video.preload === 'none' || video.preload === '') {
                        video.preload = 'auto';
                        if (video.dataset.src) {
                            video.src = video.dataset.src;
                        }
                        video.load();
                    }
                    lazyVideoObserver.unobserve(video);
                }
            });
        }, { rootMargin: '500px 0px 500px 0px' });

        document.querySelectorAll('video[preload="none"]').forEach(v => lazyVideoObserver.observe(v));

        // ─── HERO VIDEO: stacked, random on load, forward/reverse ───
        (() => {
            const wrapper = document.querySelector('.hero-video-wrapper');
            if (!wrapper) return;

            const allVids = wrapper.querySelectorAll('.hero-vid');
            const pairs = [
                { fwd: document.getElementById('hero0fwd'), rev: document.getElementById('hero0rev') },
                { fwd: document.getElementById('hero1fwd'), rev: document.getElementById('hero1rev') },
            ];

            let currentIdx = Math.floor(Math.random() * pairs.length);
            let playingForward = true;
            let heroPlaying = false;

            const activate = (vid) => {
                allVids.forEach(v => v.classList.remove('hero-active'));
                vid.classList.add('hero-active');
            };

            // Initial state
            activate(pairs[currentIdx].fwd);
            pairs[currentIdx].fwd.play().catch(() => {});
            heroPlaying = true;

            pairs.forEach(p => {
                p.fwd.addEventListener('ended', () => { heroPlaying = false; playingForward = true; });
                p.rev.addEventListener('ended', () => { heroPlaying = false; playingForward = false; });
            });

            const triggerHero = () => {
                if (heroPlaying) return;
                heroPlaying = true;
                const pair = pairs[currentIdx];
                if (playingForward) {
                    activate(pair.rev);
                    pair.rev.currentTime = 0;
                    pair.rev.play().catch(() => {});
                    playingForward = false;
                } else {
                    activate(pair.fwd);
                    pair.fwd.currentTime = 0;
                    pair.fwd.play().catch(() => {});
                    playingForward = true;
                }
            };

            // Hero pool only changes on page reload (random pick above)

            const isMobile = window.matchMedia('(max-width: 900px)').matches || 'ontouchstart' in window;

            if (isMobile) {
                wrapper.addEventListener('touchstart', triggerHero);
                let firstPlay = true;
                const heroObserver = new IntersectionObserver((entries) => {
                    entries.forEach(e => {
                        if (e.isIntersecting && !heroPlaying) {
                            if (firstPlay) { firstPlay = false; return; }
                            triggerHero();
                        }
                    });
                }, { threshold: 0.3 });
                heroObserver.observe(wrapper);
            } else {
                let mouseIsOver = false;
                wrapper.addEventListener('mouseenter', () => { mouseIsOver = true; triggerHero(); });
                wrapper.addEventListener('mouseleave', () => { mouseIsOver = false; });
                wrapper.addEventListener('click', triggerHero);
                wrapper.addEventListener('mousemove', () => { if (mouseIsOver && !heroPlaying) triggerHero(); });
            }
        })();

        // ─── SECTION VIDEOS: auto-play when scrolled into view ───
        document.querySelectorAll('.section-video').forEach(video => {
            let started = false;
            let playing = false;

            video.addEventListener('ended', () => { playing = false; });

            const playVideo = () => {
                if (playing) return;
                playing = true;
                video.currentTime = 0;
                video.play().catch(() => { playing = false; });
            };

            // Auto-play on scroll into view
            const sectionObs = new IntersectionObserver((entries) => {
                entries.forEach(e => {
                    if (e.isIntersecting && !started) {
                        started = true;
                        playVideo();
                    }
                });
            }, { threshold: 0.3 });
            sectionObs.observe(video);

            // Re-play on interaction
            video.addEventListener('click', () => { if (!playing) { started = false; playVideo(); } });
            video.addEventListener('mouseenter', () => { if (!playing) playVideo(); });
            video.addEventListener('touchstart', () => { if (!playing) playVideo(); });
        });

        // ─── CONFIDENCE VIDEO: auto-play forward on scroll, reverse on mouse over ───
        (() => {
            const cFwd = document.getElementById('confidenceFwd');
            const cRev = document.getElementById('confidenceRev');
            if (!cFwd || !cRev) return;

            let cPlaying = false;
            let cState = 'idle'; // idle -> playing-fwd -> ended-fwd -> playing-rev -> ended-rev -> ended-fwd...
            let cStarted = false;

            const showFwd = () => { cFwd.style.display = 'block'; cRev.style.display = 'none'; };
            const showRev = () => { cRev.style.display = 'block'; cFwd.style.display = 'none'; };

            // Forward finishes: stop, wait for interaction
            cFwd.addEventListener('ended', () => {
                cPlaying = false;
                cState = 'ended-fwd';
            });

            // Reverse finishes: show forward frame (reset), wait for interaction
            cRev.addEventListener('ended', () => {
                cPlaying = false;
                cState = 'ended-rev';
                showFwd();
                cFwd.currentTime = 0;
            });

            const triggerC = () => {
                if (cPlaying) return;
                if (cState === 'ended-fwd') {
                    // Play reverse
                    cPlaying = true;
                    showRev();
                    cRev.currentTime = 0;
                    cRev.play().catch(() => { cPlaying = false; });
                    cState = 'playing-rev';
                } else if (cState === 'ended-rev' || cState === 'idle') {
                    // Play forward again
                    cPlaying = true;
                    showFwd();
                    cFwd.currentTime = 0;
                    cFwd.play().catch(() => { cPlaying = false; });
                    cState = 'playing-fwd';
                }
            };

            const cWrapper = cFwd.closest('.service-video-wrapper');

            [cFwd, cRev].forEach(v => {
                v.addEventListener('click', triggerC);
                v.addEventListener('mouseenter', triggerC);
                v.addEventListener('touchstart', triggerC);
            });

            let cMouseOver = false;
            cWrapper.addEventListener('mouseenter', () => { cMouseOver = true; });
            cWrapper.addEventListener('mouseleave', () => { cMouseOver = false; });
            cWrapper.addEventListener('mousemove', () => { if (cMouseOver && !cPlaying) triggerC(); });

            // Auto-play forward on scroll into view + preload reverse
            const cObs = new IntersectionObserver((entries) => {
                entries.forEach(e => {
                    if (e.isIntersecting && !cStarted) {
                        cStarted = true;
                        cPlaying = true;
                        cState = 'playing-fwd';
                        // Preload reverse video now so it's ready
                        cRev.preload = 'auto';
                        cRev.load();
                        cFwd.play().catch(() => { cPlaying = false; });
                    }
                });
            }, { threshold: 0.3 });
            cObs.observe(cWrapper);
        })();

        // ─── ABOUT VIDEO: pool with forward/reverse, swap when off-screen ───
        (() => {
            const aboutWrapper = document.querySelector('.about-video');
            const aboutFwd = document.getElementById('aboutFwd');
            const aboutRev = document.getElementById('aboutRev');
            if (!aboutFwd || !aboutRev) return;

            const aboutPool = [
                { fwd: 'about-video.mp4', rev: 'about-video-reverse.mp4' },
                { fwd: 'about-video-2.mp4', rev: 'about-video-2-reverse.mp4' },
            ];

            let aboutIdx = Math.floor(Math.random() * aboutPool.length);
            let aboutPlaying = false;
            let aboutPlayingFwd = true;
            let aboutStarted = false;

            const loadAboutPair = (idx) => {
                aboutFwd.src = aboutPool[idx].fwd;
                aboutRev.src = aboutPool[idx].rev;
                aboutFwd.load();
                aboutRev.load();
                aboutPlayingFwd = true;
                aboutFwd.style.display = 'block';
                aboutRev.style.display = 'none';
            };

            const aboutSwap = (toVideo, fromVideo) => {
                toVideo.currentTime = 0;
                toVideo.style.display = 'block';
                fromVideo.style.display = 'none';
                toVideo.play().catch(() => {});
            };

            loadAboutPair(aboutIdx);

            const triggerAbout = () => {
                if (aboutPlaying) return;
                aboutPlaying = true;
                if (aboutPlayingFwd) {
                    aboutSwap(aboutRev, aboutFwd);
                    aboutPlayingFwd = false;
                } else {
                    aboutSwap(aboutFwd, aboutRev);
                    aboutPlayingFwd = true;
                }
            };

            aboutFwd.addEventListener('ended', () => { aboutPlaying = false; aboutPlayingFwd = true; });
            aboutRev.addEventListener('ended', () => { aboutPlaying = false; aboutPlayingFwd = false; });

            aboutFwd.addEventListener('touchstart', triggerAbout);
            aboutRev.addEventListener('touchstart', triggerAbout);
            aboutFwd.addEventListener('mouseenter', triggerAbout);
            aboutRev.addEventListener('mouseenter', triggerAbout);
            aboutFwd.addEventListener('click', triggerAbout);
            aboutRev.addEventListener('click', triggerAbout);

            let aboutMouseOver = false;
            aboutWrapper.addEventListener('mouseenter', () => { aboutMouseOver = true; });
            aboutWrapper.addEventListener('mouseleave', () => { aboutMouseOver = false; });
            aboutWrapper.addEventListener('mousemove', () => {
                if (aboutMouseOver && !aboutPlaying) triggerAbout();
            });

            // Auto-play when scrolled into view
            const aboutPlayObserver = new IntersectionObserver((entries) => {
                entries.forEach(e => {
                    if (e.isIntersecting && !aboutStarted) {
                        aboutStarted = true;
                        aboutPlaying = true;
                        aboutFwd.play().catch(() => {});
                    }
                });
            }, { threshold: 0.3 });
            aboutPlayObserver.observe(aboutWrapper);

            // Swap pool when completely off-screen
            const aboutSwapObserver = new IntersectionObserver((entries) => {
                entries.forEach(e => {
                    if (!e.isIntersecting && aboutPool.length > 1) {
                        let next;
                        do { next = Math.floor(Math.random() * aboutPool.length); } while (next === aboutIdx);
                        aboutIdx = next;
                        loadAboutPair(aboutIdx);
                        aboutPlaying = false;
                        aboutStarted = false;
                    }
                });
            }, { threshold: 0 });
            aboutSwapObserver.observe(aboutWrapper);
        })();
    </script>

</body>
</html>
